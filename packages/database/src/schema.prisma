generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlserver"
  url      = env("SQL_CONNECTION_STRING_ADMIN")
}

// NOTES
//
// use '//' comments for notes relevant to the schema
// use '///' comments for notes that should be included in the types definition
// see https://www.prisma.io/docs/concepts/components/prisma-schema#comments
//
// we use GUIDs for IDs (see https://learn.microsoft.com/en-us/sql/t-sql/data-types/uniqueidentifier-transact-sql?view=sql-server-ver16)
// this is because these IDs may be used in URLs and it makes them harder to guess
// while we don't rely on that for security, it adds an extra layer
// not everything needs this, but easier to make them all consistent and the increase in size (vs int) is negligible

/// Oidc represents an grant from the auth server
model Oidc {
  id         String    @id
  type       Int
  /// json string
  payload    String    @db.NVarChar(MAX)
  grantId    String?
  userCode   String?
  uid        String?
  expiresAt  DateTime?
  consumedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@unique([id, type])
}

/// AppealUser represents a user of our service(s)
/// this may be an appellant, agent, or LPA employee
model AppealUser {
  id         String  @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  email      String  @unique
  /// has this user been enrolled?
  /// in practice this means have they been sent a registration confirmation email
  /// this is sent to all users when they first use the system
  ///
  /// this flag is here for users created as part of migration, or from a back office ServiceUser message
  /// they need an email sent when they first login
  isEnrolled Boolean @default(false)

  /// a service user entity will be broadcast by the back office. We match them to AppealUser by email
  /// appeals will be matched to users by serviceUserId.
  serviceUserId String? // unique, with nulls allowed, is enforced in SQL, see first migration script & https://stackoverflow.com/a/767702
  // -- unique AppealUser.serviceUserId
  // CREATE UNIQUE NONCLUSTERED INDEX idx_AppealUser_serviceUserId_unique_notnull
  // ON [dbo].[AppealUser](serviceUserId)
  // WHERE serviceUserId IS NOT NULL;

  // LPA user fields
  /// is this an LPA user?
  isLpaUser  Boolean  @default(false)
  /// if an LPA user, the LPA this user belongs to
  lpaCode    String?
  /// if an LPA user, whether this user is an admin for that LPA
  isLpaAdmin Boolean?
  /// if an LPA user, the status of this user, e.g. have they logged in and confirmed their email?
  lpaStatus  String? /// added | confirmed | removed

  /// appeals this user is linked to, by being the appellant or agent, for example
  Appeals AppealToUser[]

  Rule6Parties Rule6Party[]

  /// a security token this user can use to access our service(s)
  SecurityToken SecurityToken?
}

/// SecurityToken is used as a mechanism for users to login
/// They enter their email, a token is generated, emailed to the user, and they enter it to login
/// A user only ever has one token, which gets updated when a new token is required
model SecurityToken {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  /// link to a user
  appealUserId String     @unique @db.UniqueIdentifier
  AppealUser   AppealUser @relation(fields: [appealUserId], references: [id])

  /// the generated token the user can login with
  token            String
  /// the time the token was generated, used for checking token expiry
  tokenGeneratedAt DateTime
  /// the number of attempts at entering the code since this token was last generated
  /// this MUST be updated in a transaction to ensure atomic operation
  /// see https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#atomic-number-operations
  attempts         Int      @default(0)
  /// the action the code was generated for, e.g. confirmEmail
  action           String?
}

/// Appeal is the base appeal model, used to link references to other entities, which includes, for example:
/// - an appeal submission authored in the front office
/// - a case published by the back office
/// - an LPA questionnaire submission
model Appeal {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  /// users linked to this appeal, such as the appellant or agent
  Users AppealToUser[]

  /// reference to an appeal v1 submission in the Cosmos DB `appeals` collection
  /// we sync across two properties, as below
  /// this is so we can query for draft submissions where the deadline date has passed (to delete them)
  legacyAppealSubmissionId           String?
  /// the deadline date of the appeal submission in the Cosmos DB `appeals` collection
  legacyAppealSubmissionDecisionDate DateTime?
  /// the state of the appeal submission in the Cosmos DB `appeals` collection
  legacyAppealSubmissionState        String? /// DRAFT || SUBMITTED

  /// link to case (from Back Office)
  AppealCase AppealCase?

  /// appellant v2 submission
  AppellantSubmission AppellantSubmission?
}

/// AppealToUser represents the relationships between AppealUser and Appeal
/// This is a many-to-many relationship.
model AppealToUser {
  /// relation to an Appeal
  appealId   String     @db.UniqueIdentifier
  Appeal     Appeal     @relation(fields: [appealId], references: [id])
  /// relation to a User
  userId     String     @db.UniqueIdentifier
  AppealUser AppealUser @relation(fields: [userId], references: [id])

  /// the role the user has in relation to the appeal
  /// must be an AppealToUserRole name value
  role String
  Role AppealToUserRole @relation(fields: [role], references: [name])

  @@id([appealId, userId])
}

/// AppealToUserRole represents the role a user has in relation to an Appeal
/// This reference table acts as an enum of allowed values
model AppealToUserRole {
  /// the unique name of this role such as appellant, agent, interestedParty
  /// this is a machine-readable name not a user-friendly name; i.e. lowerCamelCase
  name        String  @id
  /// the description for this role, such as
  /// "an agent is a user who submits an appeal on behalf of an appellant"
  description String?

  AppealToUser AppealToUser[]
}

/// AppealCase represents an Appeal from the Back Office, and follows the PINS Data Model
/// Cases aren't linked to users directly, but there's a 1:1 mapping to Appeal, which has a link to user
// NOTE: field names match the model rather than the usual camelCase. This avoids extra mapping.
model AppealCase {
  //***************************************************************************
  // ids/refs
  //***************************************************************************

  id            String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier /// this ID is for front office only and won't correlate to other systems
  appealId      String @unique @db.UniqueIdentifier
  Appeal        Appeal @relation(fields: [appealId], references: [id])
  caseReference String @unique /// External case identifier
  caseId        Int? /// Internal case identifier

  //***************************************************************************
  // general case fields
  //***************************************************************************

  LPACode        String /// A unique identifier for the Local Planning Authority
  appealTypeCode String? /// The type shortcode for an appeal type, e.g. HAS (Householder)
  CaseType       CaseType?      @relation(fields: [appealTypeCode], references: [processCode])
  caseStatus     String /// The processing status for the appeal
  CaseStatus     CaseStatus     @relation(fields: [caseStatus], references: [key])
  caseProcedure  String? /// The type of procedure for the appeal
  ProcedureType  ProcedureType? @relation(fields: [caseProcedure], references: [key])

  applicationReference    String? /// The unique identifier of the LPA application
  applicationDecision     String? /// The outcome of the original LPA decision
  applicationDate         DateTime? /// The date of the original LPA application
  applicationDecisionDate DateTime? /// The date of the original LPA decision
  caseSubmissionDueDate   DateTime? /// The statutory deadline for submitting an appeal from the original LPA decision date, calculated from the applicationDecisionDate

  isGreenBelt        Boolean? /// Indicates if the site is in a green belt
  inConservationArea Boolean? /// Indicates if the site is in a conservation area
  enforcementNotice  Boolean? /// Indicates if an enforcement notice is the reason for the appeal

  //***************************************************************************
  // site details
  //***************************************************************************

  siteAddressLine1             String /// First line of address for the appeal site
  siteAddressLine2             String? /// Second line of address for the appeal site
  siteAddressTown              String /// Town / City of the site address
  siteAddressCounty            String? /// County of the site address
  siteAddressPostcode          String /// Postal code of the site address
  siteAddressPostcodeSanitized String? /// Postal code of the site address
  siteAccessDetails            String?  @db.NVarChar(MAX) /// A json array of information on site accessibility
  siteSafetyDetails            String?  @db.NVarChar(MAX) /// A json array of information on site health and safety
  siteAreaSquareMetres         Decimal? /// The site area, in square meters
  floorSpaceSquareMetres       Decimal? /// The floor space, in square meters

  //***************************************************************************
  // Appellant fields
  //***************************************************************************

  appellantCostsAppliedFor       Boolean? /// Indicates if the appellant has applied for costs
  ownsAllLand                    Boolean? /// Indicates if the appellant has complete ownership of the site
  ownsSomeLand                   Boolean? /// Indicates if the appellant has partial ownership of the site
  knowsOtherOwners               String? /// Indicates if the appellant knows other owners of the site
  knowsAllOwners                 String? /// Indicates if the appellant knows all owners of the site
  advertisedAppeal               Boolean? /// Indicates if the appellant has advertised the appeal to the LPA decision
  ownersInformed                 Boolean? /// Indicates if the appellant has informed other owners of the site
  originalDevelopmentDescription String? /// The original description of the development, as provided by the appellant

  //***************************************************************************
  // LPA fields
  //***************************************************************************

  isCorrectAppealType           Boolean? /// Indicates if the LPA considers the appeal type appropriate
  lpaCostsAppliedFor            Boolean? /// Indicates if the appellant has applied for costs
  changedDevelopmentDescription Boolean? /// Indicates that the LPA has changed the development description
  newConditionDetails           String? /// New conditions details provided by the LPA
  lpaStatement                  String? /// A statement provided by the LPA

  //***************************************************************************
  // PINS provided details
  //***************************************************************************

  caseDecisionOutcome               String? /// The final outcome for the case
  CaseDecisionOutcome               CaseDecisionOutcome?               @relation(fields: [caseDecisionOutcome], references: [key])
  caseValidationOutcome             String? /// The outcome of the validation action
  CaseValidationOutcome             CaseValidationOutcome?             @relation(fields: [caseValidationOutcome], references: [key])
  lpaQuestionnaireValidationOutcome String? /// The outcome of the validation action
  LPAQuestionnaireValidationOutcome LPAQuestionnaireValidationOutcome? @relation(fields: [lpaQuestionnaireValidationOutcome], references: [key])

  // JSON arrays
  caseValidationInvalidDetails      String? @db.NVarChar(MAX) /// A json array of reasons why the appeal is invalid, will contain items only if the caseValidationOutcome is invalid
  caseValidationIncompleteDetails   String? @db.NVarChar(MAX) /// A json array of reasons why the appeal is incomplete, will contain items only if the caseValidationOutcome is incomplete
  lpaQuestionnaireValidationDetails String? @db.NVarChar(MAX) /// A json array of reasons why the questionnaire is incomplete, will contain items only if the lpaQuestionnaireValidationOutcome is incomplete

  // (unexpected FO will need to use the following PINs info)
  caseSpecialisms String? @db.NVarChar(MAX) /// A json array of specialisms for allocation purposes
  caseOfficerId   String? /// Unique identifier for the case officer assigned to the case
  inspectorId     String? /// Unique identifier for the inspector assigned to the case
  allocationLevel String? /// A level used for allocation purposes, combined with band
  allocationBand  Int? /// A band used for allocation purposes, combined with level

  //***************************************************************************
  // system dates
  //***************************************************************************

  // case dates
  caseSubmittedDate         DateTime /// The date the appeal was submitted by the appellant, i.e. submit on FO
  caseCreatedDate           DateTime /// The date the appeal was received, i.e. received from FO in BO
  caseUpdatedDate           DateTime? /// The date the appeal was last updated in the back-office
  caseValidDate             DateTime? /// The date since when the appeal was considered valid
  caseValidationDate        DateTime? /// The date the appeal was validated in the back-office
  caseExtensionDate         DateTime? /// When the validation outcome is incomplete, an extension may be granted to provide missing information
  caseStartedDate           DateTime? /// A date indicating when the case was started, resulting in the creation of a timetable
  casePublishedDate         DateTime? /// A date indicating when the case was published
  caseWithdrawnDate         DateTime? /// The date the appeal was withdrawn by the appellant
  caseTransferredDate       DateTime? /// The date the appeal was transferred to a new case of a different type
  transferredCaseClosedDate DateTime? /// The date the appeal was closed and the appellant requested to resubmit
  caseDecisionOutcomeDate   DateTime? /// The date of the appeal decision
  caseDecisionPublishedDate DateTime? /// The date the appeal decision was published (this is always null currently for HAS)
  caseCompletedDate         DateTime? /// The date the appeal decision letter

  // lpaq dates
  lpaQuestionnaireDueDate               DateTime? /// If the case is started and has a timetable, a deadline for the LPA to provide a response
  lpaQuestionnaireSubmittedDate         DateTime? /// The date the LPA provided a response to the case
  lpaQuestionnaireCreatedDate           DateTime? /// The date the LPA response was received
  lpaQuestionnairePublishedDate         DateTime? /// The date indicating when the questionnaire review was completed and the questionnaire published
  lpaQuestionnaireValidationOutcomeDate DateTime? /// The date the LPA response was validated

  //***************************************************************************
  // s78 fields - remove or rename to align with data model once created
  //***************************************************************************

  // IP dates
  interestedPartyRepsDueDate DateTime?

  // statement
  statementDueDate            DateTime?
  appellantStatementForwarded DateTime?
  appellantStatementSubmitted DateTime?
  LPAStatementForwarded       DateTime?
  LPAStatementSubmitted       DateTime?

  // comments
  finalCommentsDueDate         DateTime?
  appellantCommentsForwarded   DateTime?
  appellantCommentsSubmitted   DateTime?
  LPACommentsForwarded         DateTime?
  LPACommentsSubmitted         DateTime?
  appellantFinalCommentDetails String?

  // proofs of evidence
  proofsOfEvidenceDueDate   DateTime?
  appellantsProofsForwarded DateTime?
  appellantsProofsSubmitted DateTime?
  LPAProofsForwarded        DateTime?
  LPAProofsSubmitted        DateTime?

  scheduledMonument               Boolean @default(false)
  appellantProofEvidencePublished Boolean @default(false)
  appellantFinalCommentsSubmitted Boolean @default(false)
  lpaStatementPublished           Boolean @default(false)
  lpaProofEvidenceSubmitted       Boolean @default(false)
  lpaProofEvidencePublished       Boolean @default(false)
  lpaFinalCommentsPublished       Boolean @default(false)

  appellantProcedurePreference         String?
  appellantProcedurePreferenceDetails  String?
  appellantProcedurePreferenceDuration Int?
  lpaProcedurePreference               String?
  lpaProcedurePreferenceDetails        String?
  lpaProcedurePreferenceDuration       Int?

  conservationArea                   Boolean?
  protectedSpecies                   Boolean?
  areaOutstandingBeauty              Boolean?
  designatedSites                    String?
  otherDesignationDetails            String?
  treePreservationOrder              Boolean?
  gypsyTraveller                     Boolean?
  publicRightOfWay                   Boolean?
  environmentalImpactSchedule        String?
  developmentDescription             String?
  sensitiveArea                      Boolean?
  sensitiveAreaDetails               String?
  columnTwoThreshold                 Boolean?
  screeningOpinion                   Boolean?
  requiresEnvironmentalStatement     Boolean?
  completedEnvironmentalStatement    Boolean?
  statutoryConsultees                Boolean?
  consultedBodiesDetails             String?
  consultationResponses              Boolean?
  otherPartyRepresentations          Boolean?
  emergingPlan                       Boolean?
  supplementaryPlanningDocs          Boolean?
  infrastructureLevy                 Boolean?
  infrastructureLevyAdopted          Boolean?
  infrastructureLevyAdoptedDate      DateTime?
  infrastructureLevyExpectedDate     DateTime?
  lpaSiteAccess                      Boolean?
  lpaSiteAccessDetails               String?
  neighbouringSiteAccess             Boolean?
  neighbouringSiteAccessDetails      String?
  addNeighbouringSiteAccess          Boolean?
  lpaSiteSafetyRisks                 Boolean?
  lpaSiteSafetyRiskDetails           String?
  lpaPreferHearingDetails            String?
  lpaPreferInquiryDuration           String?
  lpaPreferInquiryDetails            String?
  lpaStatementDocuments              Boolean?
  lpaFinalComment                    Boolean?
  lpaFinalCommentDetails             String?
  lpaWitnesses                       Boolean?
  agriculturalHolding                Boolean?
  tenantAgriculturalHolding          Boolean?
  otherTenantsAgriculturalHolding    Boolean?
  informedTenantsAgriculturalHolding Boolean?
  statusPlanningObligation           String?
  planningObligation                 Boolean?

  //***************************************************************************
  // rule 6 fields
  //***************************************************************************

  rule6StatementPublished      Boolean @default(false) /// todo: use date instead
  rule6ProofsEvidencePublished Boolean @default(false) /// todo: use date instead

  //***************************************************************************
  // interested party fields
  //***************************************************************************

  interestedPartyCommentsPublished Boolean @default(false) /// todo: use date instead

  //***************************************************************************
  // Relations
  //***************************************************************************
  LPAQuestionnaireSubmission LPAQuestionnaireSubmission?
  LPAStatementSubmission     LPAStatementSubmission?
  LPAFinalCommentSubmission  LPAFinalCommentSubmission?

  AppellantFinalCommentSubmission AppellantFinalCommentSubmission?

  Rule6Parties                    Rule6Party[]
  AffectedListedBuildings         AppealCaseListedBuilding[]
  Documents                       Document[]
  NeighbouringAddresses           NeighbouringAddress[]
  Events                          Event[]
  AppealCaseLpaNotificationMethod AppealCaseLpaNotificationMethod[]
  InterestedPartyComments         InterestedPartyComment[]
  InterestedPartySubmissions      InterestedPartySubmission[]
  AppealStatements                AppealStatement[]
  AppealFinalComments             AppealFinalComment[]
}

/// AppealCase relations
/// maps all relations from a given caseReference to caseReference2
/// linked|nearby
/// linked: hierarchical + one directional, children (caseReference) will be linked to the lead (caseReference2)
/// nearby: bi-directional, (A -> B) + (B -> A)
/// No foreign keys as cases may not exist in FO yet
model AppealCaseRelationship {
  id   Int    @id @default(autoincrement())
  type String @default("nearby") /// nearby|linked

  caseReference  String
  caseReference2 String
}

/// Lookup table for types of appeals processes, and appeal types such as D (Householder) and W (S78).
/// { id: 1001, key: 'D', type: 'Householder', processCode: 'HAS' },
model CaseType {
  id          Int          @id /// used in v1 appeals see APPEAL_ID in /business-rules/src/constants.js
  key         String       @unique /// horizon type letter, also used in BO + service bus messages
  type        String       @unique /// a user friendly name for the case type
  processCode String?      @unique /// use this as foreign key, v2 appeals
  AppealCase  AppealCase[]
}

/// Lookup table for possible case procedure types.
/// ["assign_case_officer","validation","ready_to_start","lpa_questionnaire","statements","evidence","witnesses","final_comments","issue_determination","complete","invalid","closed","withdrawn","awaiting_transfer","transferred"]
model CaseStatus {
  key        String       @unique
  name       String       @unique
  AppealCase AppealCase[]
}

/// Lookup table for possible case decision outcomes
/// ["allowed", "split_decision", "dismissed", "invalid"],
model CaseDecisionOutcome {
  key        String       @unique
  name       String       @unique
  AppealCase AppealCase[]
}

/// Lookup table for possible case validation outcomes.
/// ["valid", "invalid", "incomplete"]
model CaseValidationOutcome {
  key        String       @unique
  name       String       @unique
  AppealCase AppealCase[]
}

/// Lookup table for possible LPAQ validation outcomes.
///  ["complete", "incomplete"]
model LPAQuestionnaireValidationOutcome {
  key        String       @unique
  name       String       @unique
  AppealCase AppealCase[]
}

/// Lookup table for possible case procedure types.
/// { key: 'written', name: 'Written' }
model ProcedureType {
  key         String       @id @unique
  name        String       @unique
  AppealCases AppealCase[]
}

/// Lookup table for listed buildings.
/// { reference: '1010101', name: 'A name', listedBuildingGrade: 'II' }
model ListedBuilding {
  reference                String                     @id @unique
  name                     String?
  listedBuildingGrade      String?
  AppealCaseListedBuilding AppealCaseListedBuilding[]
}

/// many to many link of appeal<->listedbuilding
model AppealCaseListedBuilding {
  id Int @id @default(autoincrement())

  caseReference String
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  listedBuildingReference String
  ListedBuilding          ListedBuilding @relation(fields: [listedBuildingReference], references: [reference])
}

/// possible notification methods.
model LPANotificationMethods {
  key                             String                            @id @unique
  name                            String                            @unique
  AppealCaseLpaNotificationMethod AppealCaseLpaNotificationMethod[]
}

model AppealCaseLpaNotificationMethod {
  id Int @id @default(autoincrement())

  caseReference String
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  lPANotificationMethodsKey String?
  LPANotificationMethod     LPANotificationMethods? @relation(fields: [lPANotificationMethodsKey], references: [key])
}

model Event {
  /// this ID is for front office only and won't correlate to other systems
  internalId String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  id                      String?
  type                    String
  subtype                 String?
  name                    String?
  status                  String? /// e.g. withdrawn
  isUrgent                Boolean   @default(false) /// it's urgent?
  published               Boolean   @default(false)
  startDate               DateTime? /// date time the event starts
  endDate                 DateTime? /// date time the event ends
  notificationOfSiteVisit DateTime? /// Date notification of site visit provided to Appellant

  // link the event to the appeal case
  caseReference String
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])
}

model NeighbouringAddress {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  addressLine1      String
  addressLine2      String?
  townCity          String
  county            String?
  postcode          String
  postcodeSanitized String?
  siteAccessDetails String? @db.NVarChar(MAX) /// json array of information on site accessibility
  siteSafetyDetails String? @db.NVarChar(MAX) /// json array of information on site health and safety

  // relations
  caseReference String
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])
}

/// Document represents a document from the Back Office, and follows the PINS Data Model
/// todo: linked to an appeal?
// NOTE: field names match the model rather than the usual camelCase. This avoids extra mapping.
model Document {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // file info
  filename             String
  originalFilename     String
  size                 Int
  mime                 String
  documentURI          String
  publishedDocumentURI String?

  // dates
  dateCreated   DateTime
  dateReceived  DateTime?
  lastModified  DateTime?
  datePublished DateTime?

  // states
  virusCheckStatus String? // nullble?
  published        Boolean @default(false)
  redacted         Boolean @default(false)
  version          Int?
  fileMD5          String?
  owner            String?
  author           String?
  description      String?

  // info
  documentType    String?
  sourceSystem    String?
  origin          String?
  stage           String?
  horizonFolderId String?

  // relations
  caseReference         String
  AppealCase            AppealCase             @relation(fields: [caseReference], references: [caseReference])
  StatementDocuments    StatementDocument[]
  FinalCommentDocuments FinalCommentDocument[]
}

// Stores appeal statements from either an LPA or rule 6 party group
model AppealStatement {
  id            String   @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  caseReference String
  serviceUserId String?
  lpaCode       String?
  statement     String?
  submittedDate DateTime

  StatementDocuments StatementDocument[]
  AppealCase         AppealCase          @relation(fields: [caseReference], references: [caseReference])
}

//Join table to link a parties statement with the correct documents
model StatementDocument {
  id          String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  statementId String @db.UniqueIdentifier
  documentId  String @db.UniqueIdentifier

  AppealStatement AppealStatement @relation(fields: [statementId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  Document        Document        @relation(fields: [documentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

// Stores appeal final comments from either an LPA, appellant or rule 6 group
model AppealFinalComment {
  id                String   @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  caseReference     String
  serviceUserId     String?  @db.UniqueIdentifier
  lpaCode           String?
  wantsFinalComment Boolean
  comments          String?
  submittedDate     DateTime

  FinalCommentDocuments FinalCommentDocument[]
  ServiceUser           ServiceUser?           @relation(fields: [serviceUserId], references: [internalId])
  AppealCase            AppealCase             @relation(fields: [caseReference], references: [caseReference])
}

// Join table to link a parties final comment with the correct documents
model FinalCommentDocument {
  id         String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  commentId  String @db.UniqueIdentifier
  documentId String @db.UniqueIdentifier

  AppealFinalComment AppealFinalComment @relation(fields: [commentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  Document           Document           @relation(fields: [documentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

// This table stores IP comments once they have been validated / processed by back office
model InterestedPartyComment {
  id            String     @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  caseReference String
  serviceUserId String?
  comment       String
  createdAt     DateTime   @default(now())
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])
}

// This table stores unedited IP submissions at the point of submission to BO
model InterestedPartySubmission {
  id            String     @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  caseReference String
  firstName     String
  lastName      String
  addressLine1  String?
  addressLine2  String?
  townCity      String?
  county        String?
  postcode      String?
  emailAddress  String?
  comments      String
  createdAt     DateTime   @default(now())
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])
}

/// ServiceUser represents any user of PINS Services, and follows the PINS Data Model
/// A given person may be represented by multiple ServiceUser entries, for example an agent
/// would have one entry per appeal
///
/// NOTE: ServiceUser should not be used for general queries, use AppealUser and AppealToUser
/// this just exists so we can create the relationships in our model, from Back Office data - which may come out of order
/// we may get an AppealCase before associated ServiceUsers, and visa versa. So we save them to reconcile afterwards.
model ServiceUser {
  /// this ID is for front office only and won't correlate to other systems
  internalId String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  id               String
  salutation       String?
  firstName        String?
  lastName         String?
  emailAddress     String?
  addressLine1     String?
  addressLine2     String?
  addressTown      String?
  addressCounty    String?
  postcode         String?
  addressCountry   String?
  organisation     String?
  organisationType String?
  role             String?
  telephoneNumber  String?
  otherPhoneNumber String?
  faxNumber        String?
  webAddress       String?
  sourceSystem     String?
  sourceSuid       String?

  /// one of "Applicant", "Appellant", "Agent", "RepresentationContact", "Subscriber"
  serviceUserType String
  /// case reference this user + user-type relates to
  caseReference   String

  AppealFinalComments AppealFinalComment[]
}

/// AppellantSubmission represents an appeal submitted by an appellant
model AppellantSubmission {
  id             String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  LPACode        String
  appealTypeCode String // type shortcode such as HAS or S78

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // application
  applicationDecisionDate DateTime?
  applicationDecision     String?

  appealId String @unique @db.UniqueIdentifier
  Appeal   Appeal @relation(fields: [appealId], references: [id])

  // state
  caseTermsAccepted Boolean? /// set when user clicks submit
  submitted         Boolean  @default(false) /// whether the questionnaire has been submitted to BO
  submissionPdfId   String?

  // dates
  onApplicationDate DateTime?

  //appellant / agent details
  isAppellant          Boolean?
  appellantFirstName   String?
  appellantLastName    String?
  appellantCompanyName String?
  contactFirstName     String?
  contactLastName      String?
  contactCompanyName   String?

  // boolean
  ownsAllLand                        Boolean?
  ownsSomeLand                       Boolean?
  knowsAllOwners                     String?
  knowsOtherOwners                   String?
  informedOwners                     Boolean?
  advertisedAppeal                   Boolean?
  appellantGreenBelt                 Boolean?
  updateDevelopmentDescription       Boolean?
  identifiedOwners                   Boolean?
  costApplication                    Boolean?
  appellantProcedurePreference       String?
  agriculturalHolding                Boolean?
  informedTenantsAgriculturalHolding Boolean?
  otherTenantsAgriculturalHolding    Boolean?
  ownershipCertificate               Boolean?
  newPlansDrawings                   Boolean?
  otherNewDocuments                  Boolean?
  designAccessStatement              Boolean?
  planningObligation                 Boolean?
  tenantAgriculturalHolding          Boolean?

  // boolean text
  appellantSiteSafety                            String?
  appellantSiteSafety_appellantSiteSafetyDetails String?
  appellantSiteAccess                            String?
  appellantSiteAccess_appellantSiteAccessDetails String?
  statusPlanningObligation                       String?

  // plain text
  applicationReference           String?
  developmentDescriptionOriginal String?
  appellantLinkedCaseReference   String?
  contactPhoneNumber             String?
  appellantPreferHearingDetails  String?
  appellantPreferInquiryDetails  String?

  // number entries
  siteAreaSquareMetres            Decimal?
  siteAreaUnits                   String?
  appellantPreferInquiryDuration  Int?
  appellantPreferInquiryWitnesses Int?
  siteArea                        Decimal?

  // Linked cases
  appellantLinkedCaseAdd Boolean?
  appellantLinkedCase    Boolean?
  SubmissionLinkedCase   SubmissionLinkedCase[]

  // file uploads
  uploadOriginalApplicationForm     Boolean?
  uploadApplicationDecisionLetter   Boolean?
  uploadAppellantStatement          Boolean?
  uploadCostApplication             Boolean?
  uploadChangeOfDescriptionEvidence Boolean?
  uploadOwnershipCertificate        Boolean?
  uploadStatementCommonGround       Boolean?
  uploadDesignAccessStatement       Boolean?
  uploadPlansDrawings               Boolean?
  uploadNewPlansDrawings            Boolean?
  uploadOtherNewDocuments           Boolean?
  uploadPlanningObligation          Boolean?
  SubmissionDocumentUpload          SubmissionDocumentUpload[]

  // addresses
  siteAddress              Boolean?
  SubmissionAddress        SubmissionAddress[]
  SubmissionListedBuilding SubmissionListedBuilding[]
}

/// LPAQuestionnaireSubmission represents the questionnaire responses from an LPAUser
model LPAQuestionnaireSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  appealCaseReference String     @unique
  AppealCase          AppealCase @relation(fields: [appealCaseReference], references: [caseReference])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the appeal has been submitted to BO

  correctAppealType                               Boolean?
  affectsListedBuilding                           Boolean?
  affectedListedBuildingNumber                    String?
  addAffectedListedBuilding                       Boolean?
  changesListedBuilding                           Boolean?
  changedListedBuildingNumber                     String?
  addChangedListedBuilding                        Boolean?
  conservationArea                                Boolean?
  uploadConservation                              Boolean?
  greenBelt                                       Boolean?
  uploadWhoNotified                               Boolean?
  uploadLettersEmails                             Boolean?
  uploadPressAdvert                               Boolean?
  consultationResponses                           Boolean?
  uploadConsultationResponses                     Boolean?
  notificationMethod                              String?
  uploadSiteNotice                                Boolean?
  otherPartyRepresentations                       Boolean?
  uploadRepresentations                           Boolean?
  uploadPlanningOfficerReport                     Boolean?
  uploadPlansDrawings                             Boolean?
  lpaSiteAccess                                   String?
  lpaSiteAccess_lpaSiteAccessDetails              String?
  neighbourSiteAccess                             String?
  neighbourSiteAccess_neighbourSiteAccessDetails  String?
  addNeighbourSiteAccess                          Boolean?
  neighbourSiteAddress                            Boolean?
  lpaSiteSafetyRisks                              String?
  lpaSiteSafetyRisks_lpaSiteSafetyRiskDetails     String?
  lpaProcedurePreference                          String?
  lpaPreferHearingDetails                         String?
  lpaProcedurePreference_lpaPreferInquiryDuration String?
  lpaPreferInquiryDetails                         String?
  nearbyAppeals                                   Boolean?
  addNearbyAppeal                                 Boolean?
  newConditions                                   String?
  newConditions_newConditionDetails               String?
  emergingPlan                                    Boolean?
  uploadEmergingPlan                              Boolean?
  uploadDevelopmentPlanPolicies                   Boolean?
  uploadOtherPolicies                             Boolean?
  infrastructureLevy                              Boolean?
  uploadInfrastructureLevy                        Boolean?
  infrastructureLevyAdopted                       Boolean?
  infrastructureLevyAdoptedDate                   DateTime?
  infrastructureLevyExpectedDate                  DateTime?
  uploadLettersInterestedParties                  Boolean?
  treePreservationOrder                           Boolean?
  uploadTreePreservationOrder                     Boolean?
  uploadDefinitiveMapStatement                    Boolean?
  supplementaryPlanningDocs                       Boolean?
  uploadSupplementaryPlanningDocs                 Boolean?
  affectsScheduledMonument                        Boolean?
  gypsyTraveller                                  Boolean?
  statutoryConsultees                             String?
  statutoryConsultees_consultedBodiesDetails      String?
  protectedSpecies                                Boolean?
  publicRightOfWay                                Boolean?
  areaOutstandingBeauty                           Boolean?
  designatedSites                                 String?
  designatedSites_otherDesignations               String?
  screeningOpinion                                Boolean?
  environmentalStatement                          Boolean?
  environmentalImpactSchedule                     String?
  uploadEnvironmentalStatement                    Boolean?
  columnTwoThreshold                              Boolean?
  sensitiveArea                                   String?
  sensitiveArea_sensitiveAreaDetails              String?
  uploadScreeningOpinion                          Boolean?
  uploadScreeningDirection                        Boolean?
  developmentDescription                          String?
  requiresEnvironmentalStatement                  String?

  // Uploaded documents and details linked to this appeal
  SubmissionDocumentUpload SubmissionDocumentUpload[]
  SubmissionAddress        SubmissionAddress[]
  SubmissionLinkedCase     SubmissionLinkedCase[]
  SubmissionListedBuilding SubmissionListedBuilding[]
}

model LPAStatementSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  appealCaseReference String     @unique
  AppealCase          AppealCase @relation(fields: [appealCaseReference], references: [caseReference])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the appeal has been submitted to BO

  lpaStatement        String?
  additionalDocuments Boolean?

  // Uploaded documents and details linked to this appeal
  uploadLpaStatementDocuments Boolean?
  SubmissionDocumentUpload    SubmissionDocumentUpload[]
}

model LPAFinalCommentSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  caseReference String     @unique
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the appeal has been submitted to BO

  lpaFinalComment                Boolean?
  lpaFinalCommentDetails         String?
  lpaFinalCommentDocuments       Boolean?
  uploadLPAFinalCommentDocuments Boolean?

  // Uploaded documents and details linked to this appeal
  SubmissionDocumentUpload SubmissionDocumentUpload[]
}

model AppellantFinalCommentSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  caseReference String     @unique
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the appeal has been submitted to BO

  appellantFinalComment                Boolean?
  appellantFinalCommentDetails         String?
  appellantFinalCommentDocuments       Boolean?
  uploadAppellantFinalCommentDocuments Boolean?

  // Uploaded documents and details linked to this appeal
  SubmissionDocumentUpload SubmissionDocumentUpload[]
}

model SubmissionDocumentUpload {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  questionnaireId            String?                     @db.UniqueIdentifier
  LPAQuestionnaireSubmission LPAQuestionnaireSubmission? @relation(fields: [questionnaireId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  appellantSubmissionId String?              @db.UniqueIdentifier
  AppellantSubmission   AppellantSubmission? @relation(fields: [appellantSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  lpaStatementId         String?                 @db.UniqueIdentifier
  LPAStatementSubmission LPAStatementSubmission? @relation(fields: [lpaStatementId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  appellantFinalCommentId         String?                          @db.UniqueIdentifier
  AppellantFinalCommentSubmission AppellantFinalCommentSubmission? @relation(fields: [appellantFinalCommentId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  lpaFinalCommentId         String?                    @db.UniqueIdentifier
  LPAFinalCommentSubmission LPAFinalCommentSubmission? @relation(fields: [lpaFinalCommentId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  name             String
  fileName         String
  originalFileName String
  location         String
  type             String
  storageId        String @default("")
}

model SubmissionAddress {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  questionnaireId            String?                     @db.UniqueIdentifier
  LPAQuestionnaireSubmission LPAQuestionnaireSubmission? @relation(fields: [questionnaireId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  appellantSubmissionId String?              @db.UniqueIdentifier
  AppellantSubmission   AppellantSubmission? @relation(fields: [appellantSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  addressLine1 String
  addressLine2 String?
  townCity     String
  county       String?
  postcode     String

  // the fieldName of the questionnaire question / subquestion - required for display filtering
  fieldName String
}

model SubmissionLinkedCase {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  lPAQuestionnaireSubmissionId String?                     @db.UniqueIdentifier
  LPAQuestionnaireSubmission   LPAQuestionnaireSubmission? @relation(fields: [lPAQuestionnaireSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  appellantSubmissionId String?              @db.UniqueIdentifier
  AppellantSubmission   AppellantSubmission? @relation(fields: [appellantSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  caseReference String

  // the fieldName of the questionnaire question / subquestion - required for display filtering
  fieldName String
}

model SubmissionListedBuilding {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  lPAQuestionnaireSubmissionId String?                     @db.UniqueIdentifier
  LPAQuestionnaireSubmission   LPAQuestionnaireSubmission? @relation(fields: [lPAQuestionnaireSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  appellantSubmissionId String?              @db.UniqueIdentifier
  AppellantSubmission   AppellantSubmission? @relation(fields: [appellantSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  reference           String
  name                String
  listedBuildingGrade String

  // the fieldName of the questionnaire question / subquestion - required for display filtering
  fieldName String
}

model Rule6Party {
  id                                 String    @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  caseReference                      String
  firstName                          String
  lastName                           String
  over18                             Boolean
  partyName                          String
  partyEmail                         String
  addressLine1                       String
  addressLine2                       String?
  addressTown                        String?
  addressCounty                      String?
  addressPostcode                    String?
  partyStatus                        String
  proofEvidenceSubmitted             Boolean
  proofEvidenceSubmittedDate         DateTime?
  proofEvidenceReceived              Boolean
  proofEvidenceReceivedDate          DateTime?
  proofEvidenceValidationOutcome     String?
  proofEvidenceValidationOutcomeDate DateTime?
  proofEvidenceValidationDetails     String?
  statementDocuments                 Boolean
  witnesses                          Boolean
  statementSubmitted                 Boolean
  statementSubmittedDate             DateTime?
  statementReceived                  Boolean
  statementReceivedDate              DateTime?
  statementValidationOutcome         String?
  statementValidationOutcomeDate     DateTime?
  statementValidationDetails         String?

  // Link to AppealUser
  appealUserId String     @db.UniqueIdentifier
  AppealUser   AppealUser @relation(fields: [appealUserId], references: [id])

  //Optional link to AppealCase
  AppealCase AppealCase? @relation(fields: [caseReference], references: [caseReference])
}
