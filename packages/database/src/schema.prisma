generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlserver"
  url      = env("SQL_CONNECTION_STRING_ADMIN")
}

// NOTES
//
// use '//' comments for notes relevant to the schema
// use '///' comments for notes that should be included in the types definition
// see https://www.prisma.io/docs/concepts/components/prisma-schema#comments
//
// we use GUIDs for IDs (see https://learn.microsoft.com/en-us/sql/t-sql/data-types/uniqueidentifier-transact-sql?view=sql-server-ver16)
// this is because these IDs may be used in URLs and it makes them harder to guess
// while we don't rely on that for security, it adds an extra layer
// not everything needs this, but easier to make them all consistent and the increase in size (vs int) is negligible

/// Oidc represents an grant from the auth server
model Oidc {
  id         String    @id
  type       Int
  /// json string
  payload    String    @db.NVarChar(MAX)
  grantId    String?
  userCode   String?
  uid        String?
  expiresAt  DateTime?
  consumedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@unique([id, type])
}

/// AppealUser represents a user of our service(s)
/// this may be an appellant, agent, or LPA employee
model AppealUser {
  id         String  @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  email      String  @unique
  /// has this user been enrolled?
  /// in practice this means have they been sent a registration confirmation email
  /// this is sent to all users when they first use the system
  ///
  /// this flag is here for users created as part of migration, or from a back office ServiceUser message
  /// they need an email sent when they first login
  isEnrolled Boolean @default(false)

  // LPA user fields
  /// is this an LPA user?
  isLpaUser  Boolean  @default(false)
  /// if an LPA user, the LPA this user belongs to
  lpaCode    String?
  /// if an LPA user, whether this user is an admin for that LPA
  isLpaAdmin Boolean?
  /// if an LPA user, the status of this user, e.g. have they logged in and confirmed their email?
  lpaStatus  String? /// added | confirmed | removed

  /// appeals this user is linked to, by being the appellant or agent, for example
  Appeals AppealToUser[]

  /// a security token this user can use to access our service(s)
  SecurityToken                  SecurityToken?
  Rule6ProofOfEvidenceSubmission Rule6ProofOfEvidenceSubmission[]
  Rule6StatementSubmission       Rule6StatementSubmission[]

  // indexes
  @@index([email])
  @@index([lpaCode])
}

/// SecurityToken is used as a mechanism for users to login
/// They enter their email, a token is generated, emailed to the user, and they enter it to login
/// A user only ever has one token, which gets updated when a new token is required
model SecurityToken {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  /// link to a user
  appealUserId String     @unique @db.UniqueIdentifier
  AppealUser   AppealUser @relation(fields: [appealUserId], references: [id])

  /// the generated token the user can login with
  token            String
  /// the time the token was generated, used for checking token expiry
  tokenGeneratedAt DateTime
  /// the number of attempts at entering the code since this token was last generated
  /// this MUST be updated in a transaction to ensure atomic operation
  /// see https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#atomic-number-operations
  attempts         Int      @default(0)
  /// the action the code was generated for, e.g. confirmEmail
  action           String?

  // indexes
  @@index([appealUserId])
}

/// Appeal is the base appeal model, used to link references to other entities, which includes, for example:
/// - an appeal submission authored in the front office
/// - a case published by the back office
/// - an LPA questionnaire submission
model Appeal {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  /// users linked to this appeal, such as the appellant or agent
  Users AppealToUser[]

  /// reference to an appeal v1 submission in the Cosmos DB `appeals` collection
  /// we sync across two properties, as below
  /// this is so we can query for draft submissions where the deadline date has passed (to delete them)
  legacyAppealSubmissionId           String?
  /// the deadline date of the appeal submission in the Cosmos DB `appeals` collection
  legacyAppealSubmissionDecisionDate DateTime?
  /// the state of the appeal submission in the Cosmos DB `appeals` collection
  legacyAppealSubmissionState        String? /// DRAFT || SUBMITTED

  /// link to case (from Back Office)
  AppealCase AppealCase?

  /// appellant v2 submission
  AppellantSubmission AppellantSubmission?

  // indexes
  @@index([legacyAppealSubmissionId])
}

/// AppealToUser represents the relationships between AppealUser and Appeal
/// This is a many-to-many relationship.
model AppealToUser {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  /// relation to an Appeal
  appealId   String     @db.UniqueIdentifier
  Appeal     Appeal     @relation(fields: [appealId], references: [id])
  /// relation to a User
  userId     String     @db.UniqueIdentifier
  AppealUser AppealUser @relation(fields: [userId], references: [id])

  /// the role the user has in relation to the appeal
  /// must be an AppealToUserRole name value
  role String
  Role AppealToUserRole @relation(fields: [role], references: [name])

  // indexes
  @@index([appealId])
  @@index([userId])
  @@index([role])
}

/// AppealToUserRole represents the role a user has in relation to an Appeal
/// This reference table acts as an enum of allowed values
model AppealToUserRole {
  /// the unique name of this role such as appellant, agent, interestedParty
  /// this is a machine-readable name not a user-friendly name; i.e. lowerCamelCase
  name        String  @id
  /// the description for this role, such as
  /// "an agent is a user who submits an appeal on behalf of an appellant"
  description String?

  AppealToUser AppealToUser[]
}

/// AppealCase represents an Appeal from the Back Office, and follows the PINS Data Model
/// Cases aren't linked to users directly, but there's a 1:1 mapping to Appeal, which has a link to user
// NOTE: field names match the model rather than the usual camelCase. This avoids extra mapping.
model AppealCase {
  //***************************************************************************
  // ids/refs
  //***************************************************************************

  id            String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier /// this ID is for front office only and won't correlate to other systems
  appealId      String @unique @db.UniqueIdentifier
  Appeal        Appeal @relation(fields: [appealId], references: [id])
  caseReference String @unique /// External case identifier
  caseId        Int? /// Internal case identifier

  //***************************************************************************
  // general case fields
  //***************************************************************************

  LPACode        String /// A unique identifier for the Local Planning Authority
  appealTypeCode String? /// The type shortcode for an appeal type, e.g. HAS (Householder)
  CaseType       CaseType?      @relation(fields: [appealTypeCode], references: [processCode])
  caseStatus     String /// The processing status for the appeal
  CaseStatus     CaseStatus     @relation(fields: [caseStatus], references: [key])
  caseProcedure  String? /// The type of procedure for the appeal
  ProcedureType  ProcedureType? @relation(fields: [caseProcedure], references: [key])

  applicationReference      String? /// The unique identifier of the LPA application
  applicationDecision       String? /// The outcome of the original LPA decision
  applicationDate           DateTime? /// The date of the original LPA application
  applicationDecisionDate   DateTime? /// The date of the original LPA decision
  caseSubmissionDueDate     DateTime? /// The statutory deadline for submitting an appeal from the original LPA decision date, calculated from the applicationDecisionDate
  enforcementNotice         Boolean? /// Indicates if an enforcement notice is the reason for the appeal
  developmentType           String? /// the type of develpoment
  typeOfPlanningApplication String? /// the type of planning application

  isGreenBelt           Boolean? /// Indicates if the site is in a green belt
  inConservationArea    Boolean? /// Indicates if the site is in a conservation area
  scheduledMonument     Boolean? /// Indicates that a scheduled monument is affected
  protectedSpecies      Boolean? /// Indicates the existence of protected species
  areaOutstandingBeauty Boolean? /// Indicates an area of outstanding beauty (National Landscape)
  gypsyTraveller        Boolean? /// Indicates a traveller site
  publicRightOfWay      Boolean? /// Indicates a PROW (public right of way)

  //***************************************************************************
  // site details
  //***************************************************************************

  siteAddressLine1             String /// First line of address for the appeal site
  siteAddressLine2             String? /// Second line of address for the appeal site
  siteAddressTown              String /// Town / City of the site address
  siteAddressCounty            String? /// County of the site address
  siteAddressPostcode          String /// Postal code of the site address
  siteAddressPostcodeSanitized String? /// Postal code of the site address
  siteAccessDetails            String?  @db.NVarChar(MAX) /// A json array of information on site accessibility
  siteSafetyDetails            String?  @db.NVarChar(MAX) /// A json array of information on site health and safety
  siteAreaSquareMetres         Decimal? /// The site area, in square meters
  floorSpaceSquareMetres       Decimal? /// The floor space, in square meters
  siteGridReferenceEasting     String? /// Eastings of the site
  siteGridReferenceNorthing    String? /// Northing of the site

  //***************************************************************************
  // Appellant fields
  //***************************************************************************

  appellantCostsAppliedFor       Boolean? /// Indicates if the appellant has applied for costs
  originalDevelopmentDescription String? /// The original description of the development, as provided by the appellant
  statusPlanningObligation       String? /// The planning obligation information, if available

  ownsAllLand      Boolean? /// Indicates if the appellant has complete ownership of the site
  ownsSomeLand     Boolean? /// Indicates if the appellant has partial ownership of the site
  knowsOtherOwners String? /// Indicates if the appellant knows other owners of the site
  knowsAllOwners   String? /// Indicates if the appellant knows all owners of the site
  advertisedAppeal Boolean? /// Indicates if the appellant has advertised the appeal to the LPA decision
  ownersInformed   Boolean? /// Indicates if the appellant has informed other owners of the site

  agriculturalHolding                Boolean? /// Indicates if the site is an agricultural holding
  tenantAgriculturalHolding          Boolean? /// Indicates if the site is a tenant agricultural holding
  otherTenantsAgriculturalHolding    Boolean? /// Indicates if the site is an agricultural holding with other tenants
  informedTenantsAgriculturalHolding Boolean? /// If the site is an agricultural holding, indicates tenants are informed

  appellantProcedurePreference             String? /// The procedure preference indicated by the appellant
  appellantProcedurePreferenceDetails      String? /// The procedure details preference indicated by the appellant
  appellantProcedurePreferenceDuration     Int? /// The duration of the procedure indicated by the appellant
  appellantProcedurePreferenceWitnessCount Int? /// The number of witnesses appellant has suggested for inquiries preference

  //***************************************************************************
  // LPA fields
  //***************************************************************************

  isCorrectAppealType           Boolean? /// Indicates if the LPA considers the appeal type appropriate
  lpaCostsAppliedFor            Boolean? /// Indicates if the LPA has applied for costs
  changedDevelopmentDescription Boolean? /// Indicates that the LPA has changed the development description
  newConditionDetails           String?  @db.NVarChar(Max) /// New conditions details provided by the LPA

  // todo: remove this column is an rep
  lpaStatement String? /// A statement provided by the LPA

  lpaProcedurePreference         String? /// The procedure preference indicated by the LPA
  lpaProcedurePreferenceDetails  String? /// The procedure details preference indicated by the LPA
  lpaProcedurePreferenceDuration Int? /// The duration of enquiry indicated by the LPA

  statutoryConsultees    Boolean? /// Indicates if the LPA consulted all the relevant statutory consultees
  consultedBodiesDetails String? /// The details of the bodies consulted by the LPA

  reasonForNeighbourVisits String? /// Reason given for the need to visit neighbours

  designatedSitesNames String? @db.NVarChar(MAX) /// A json array of designated site names

  //***************************************************************************
  // Environmental Impact Assesement fields
  //***************************************************************************

  environmentalImpactSchedule     String?
  developmentDescription          String?
  sensitiveAreaDetails            String?
  columnTwoThreshold              Boolean?
  screeningOpinion                Boolean?
  requiresEnvironmentalStatement  Boolean?
  completedEnvironmentalStatement Boolean?

  //***************************************************************************
  // Infrastructure levy fields
  //***************************************************************************

  infrastructureLevy             Boolean?
  infrastructureLevyAdopted      Boolean?
  infrastructureLevyAdoptedDate  DateTime?
  infrastructureLevyExpectedDate DateTime?

  //***************************************************************************
  // PINS provided details
  //***************************************************************************

  caseDecisionOutcome               String? /// The final outcome for the case
  CaseDecisionOutcome               CaseDecisionOutcome?               @relation(fields: [caseDecisionOutcome], references: [key])
  caseValidationOutcome             String? /// The outcome of the validation action
  CaseValidationOutcome             CaseValidationOutcome?             @relation(fields: [caseValidationOutcome], references: [key])
  lpaQuestionnaireValidationOutcome String? /// The outcome of the validation action
  LPAQuestionnaireValidationOutcome LPAQuestionnaireValidationOutcome? @relation(fields: [lpaQuestionnaireValidationOutcome], references: [key])

  // JSON arrays
  caseValidationInvalidDetails      String? @db.NVarChar(MAX) /// A json array of reasons why the appeal is invalid, will contain items only if the caseValidationOutcome is invalid
  caseValidationIncompleteDetails   String? @db.NVarChar(MAX) /// A json array of reasons why the appeal is incomplete, will contain items only if the caseValidationOutcome is incomplete
  lpaQuestionnaireValidationDetails String? @db.NVarChar(MAX) /// A json array of reasons why the questionnaire is incomplete, will contain items only if the lpaQuestionnaireValidationOutcome is incomplete

  // (unexpected FO will need to use the following PINs info)
  caseSpecialisms String? @db.NVarChar(MAX) /// A json array of specialisms for allocation purposes
  caseOfficerId   String? /// Unique identifier for the case officer assigned to the case
  inspectorId     String? /// Unique identifier for the inspector assigned to the case
  allocationLevel String? /// A level used for allocation purposes, combined with band
  allocationBand  Int? /// A band used for allocation purposes, combined with level

  //***************************************************************************
  // system dates
  //***************************************************************************

  // case dates
  caseSubmittedDate         DateTime /// The date the appeal was submitted by the appellant, i.e. submit on FO
  caseCreatedDate           DateTime /// The date the appeal was received, i.e. received from FO in BO
  caseUpdatedDate           DateTime? /// The date the appeal was last updated in the back-office
  caseValidDate             DateTime? /// The date since when the appeal was considered valid
  caseValidationDate        DateTime? /// The date the appeal was validated in the back-office
  caseExtensionDate         DateTime? /// When the validation outcome is incomplete, an extension may be granted to provide missing information
  caseStartedDate           DateTime? /// A date indicating when the case was started, resulting in the creation of a timetable
  casePublishedDate         DateTime? /// A date indicating when the case was published
  caseWithdrawnDate         DateTime? /// The date the appeal was withdrawn by the appellant
  caseTransferredDate       DateTime? /// The date the appeal was transferred to a new case of a different type
  transferredCaseClosedDate DateTime? /// The date the appeal was closed and the appellant requested to resubmit
  caseDecisionOutcomeDate   DateTime? /// The date of the appeal decision
  caseDecisionPublishedDate DateTime? /// The date the appeal decision was published (this is always null currently for HAS)
  caseCompletedDate         DateTime? /// The date the appeal decision letter

  // lpaq dates
  lpaQuestionnaireDueDate               DateTime? /// If the case is started and has a timetable, a deadline for the LPA to provide a response
  lpaQuestionnaireSubmittedDate         DateTime? /// The date the LPA provided a response to the case
  lpaQuestionnaireCreatedDate           DateTime? /// The date the LPA response was received
  lpaQuestionnairePublishedDate         DateTime? /// The date indicating when the questionnaire review was completed and the questionnaire published
  lpaQuestionnaireValidationOutcomeDate DateTime? /// The date the LPA response was validated

  // statements
  statementDueDate                DateTime? /// date statements are due by
  appellantStatementSubmittedDate DateTime? /// date appellant submitted their statement
  LPAStatementSubmittedDate       DateTime? /// date lpa submitted their statement

  // final comments
  finalCommentsDueDate           DateTime? /// date final comments are due by
  appellantCommentsSubmittedDate DateTime? /// date appellant submitted their final comment
  LPACommentsSubmittedDate       DateTime? /// date lpa submitted their final comment

  // IP dates
  interestedPartyRepsDueDate DateTime? /// date Interested party comments are due by

  // proofs of evidence
  proofsOfEvidenceDueDate      DateTime? /// date proofs-of-evidence/witnesses are due by
  LPAProofsSubmittedDate       DateTime? /// date lpa submitted their proofs-of-evidence/witnesses
  appellantProofsSubmittedDate DateTime? /// date appellant submitted their proofs-of-evidence/witnesses

  //***************************************************************************
  // s78 fields
  //***************************************************************************

  // todo: in data model but not asked or handled anywhere?
  siteWithinSSSI                Boolean? // SSSI is an option for designatedSites
  siteViewableFromRoad          Boolean? // todo: could map from site access details, otherwise not in command
  caseworkReason                String?
  importantInformation          String?
  jurisdiction                  String?
  redeterminedIndicator         String?
  numberOfResidencesNetChange   Int?
  // consistent naming for date fields?
  dateNotRecoveredOrDerecovered DateTime?
  dateRecovered                 DateTime?
  originalCaseDecisionDate      DateTime?
  targetDate                    DateTime?
  siteNoticesSentDate           DateTime?
  dateCostsReportDespatched     DateTime?

  //***************************************************************************
  // s20 fields
  //***************************************************************************
  preserveGrantLoan      Boolean?
  consultHistoricEngland Boolean?

  //***************************************************************************
  // Relations
  //***************************************************************************

  LPAQuestionnaireSubmission   LPAQuestionnaireSubmission?
  LPAStatementSubmission       LPAStatementSubmission?
  LPAFinalCommentSubmission    LPAFinalCommentSubmission?
  LPAProofOfEvidenceSubmission LPAProofOfEvidenceSubmission?

  AppellantFinalCommentSubmission    AppellantFinalCommentSubmission?
  AppellantProofOfEvidenceSubmission AppellantProofOfEvidenceSubmission?

  ListedBuildings                 AppealCaseListedBuilding[]
  Documents                       Document[]
  NeighbouringAddresses           NeighbouringAddress[]
  Events                          Event[]
  AppealCaseLpaNotificationMethod AppealCaseLpaNotificationMethod[]
  InterestedPartySubmissions      InterestedPartySubmission[]
  Rule6ProofOfEvidenceSubmission  Rule6ProofOfEvidenceSubmission?
  Rule6StatementSubmission        Rule6StatementSubmission?
  Representations                 Representation[]

  // indexes
  @@index([LPACode])
  @@index([casePublishedDate])
  @@index([caseDecisionOutcomeDate])
  @@index([siteAddressPostcodeSanitized])
}

/// AppealCase relations
/// maps all relations from a given caseReference to caseReference2
/// linked|nearby
/// linked: hierarchical + one directional, children (caseReference) will be linked to the lead (caseReference2)
/// nearby: bi-directional, (A -> B) + (B -> A)
/// No foreign keys as cases may not exist in FO yet
model AppealCaseRelationship {
  id   Int    @id @default(autoincrement())
  type String @default("nearby") /// nearby|linked

  caseReference  String
  caseReference2 String

  // indexes
  @@index([caseReference])
  @@index([caseReference2])
}

/// Lookup table for types of appeals processes, and appeal types such as D (Householder) and W (S78).
/// { id: 1001, key: 'D', type: 'Householder', processCode: 'HAS' },
model CaseType {
  id          Int          @id /// used in v1 appeals see APPEAL_ID in /business-rules/src/constants.js
  key         String /// horizon type letter, also used in BO + service bus messages (not unique)
  type        String       @unique /// a user friendly name for the case type
  processCode String?      @unique /// use this as foreign key, v2 appeals
  AppealCase  AppealCase[]
}

/// Lookup table for possible case procedure types.
/// ["assign_case_officer","validation","ready_to_start","lpa_questionnaire","statements","evidence","witnesses","final_comments","issue_determination","complete","invalid","closed","withdrawn","awaiting_transfer","transferred"]
model CaseStatus {
  key        String       @unique
  name       String       @unique
  AppealCase AppealCase[]
}

/// Lookup table for possible case decision outcomes
/// ["allowed", "split_decision", "dismissed", "invalid"],
model CaseDecisionOutcome {
  key        String       @unique
  name       String       @unique
  AppealCase AppealCase[]
}

/// Lookup table for possible case validation outcomes.
/// ["valid", "invalid", "incomplete"]
model CaseValidationOutcome {
  key        String       @unique
  name       String       @unique
  AppealCase AppealCase[]
}

/// Lookup table for possible LPAQ validation outcomes.
///  ["complete", "incomplete"]
model LPAQuestionnaireValidationOutcome {
  key        String       @unique
  name       String       @unique
  AppealCase AppealCase[]
}

/// Lookup table for possible case procedure types.
/// { key: 'written', name: 'Written' }
model ProcedureType {
  key         String       @id @unique
  name        String       @unique
  AppealCases AppealCase[]
}

/// Lookup table for listed buildings.
/// { reference: '1010101', name: 'A name', listedBuildingGrade: 'II' }
model ListedBuilding {
  reference                String                     @id @unique
  name                     String?
  listedBuildingGrade      String?
  AppealCaseListedBuilding AppealCaseListedBuilding[]
}

/// many to many link of appeal<->listedbuilding
model AppealCaseListedBuilding {
  id Int @id @default(autoincrement())

  caseReference String
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  listedBuildingReference String
  ListedBuilding          ListedBuilding @relation(fields: [listedBuildingReference], references: [reference])

  type String @default("affected")

  // indexes
  @@index([caseReference])
  @@index([listedBuildingReference])
}

/// possible notification methods.
model LPANotificationMethods {
  key                             String                            @id @unique
  name                            String                            @unique
  AppealCaseLpaNotificationMethod AppealCaseLpaNotificationMethod[]
}

model AppealCaseLpaNotificationMethod {
  id Int @id @default(autoincrement())

  caseReference String
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  lPANotificationMethodsKey String?
  LPANotificationMethod     LPANotificationMethods? @relation(fields: [lPANotificationMethodsKey], references: [key])

  // indexes
  @@index([caseReference])
  @@index([lPANotificationMethodsKey])
}

model Event {
  /// this ID is for front office only and won't correlate to other systems
  internalId String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  id                      String?
  type                    String
  subtype                 String?
  name                    String?
  status                  String? /// e.g. withdrawn
  isUrgent                Boolean   @default(false) /// it's urgent?
  published               Boolean   @default(false)
  startDate               DateTime? /// date time the event starts
  endDate                 DateTime? /// date time the event ends
  notificationOfSiteVisit DateTime? /// Date notification of site visit provided to Appellant
  addressLine1            String? /// event site first line of address
  addressLine2            String? /// event site second line of address
  addressTown             String? /// event site town or city
  addressCounty           String? /// event site county
  addressPostcode         String? /// event site postcode

  // link the event to the appeal case
  caseReference String
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  // indexes
  @@index([caseReference])
}

model NeighbouringAddress {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  addressLine1      String
  addressLine2      String?
  townCity          String
  county            String?
  postcode          String
  postcodeSanitized String?
  siteAccessDetails String? @db.NVarChar(MAX) /// json array of information on site accessibility
  siteSafetyDetails String? @db.NVarChar(MAX) /// json array of information on site health and safety

  // relations
  caseReference String
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  // indexes
  @@index([caseReference])
}

/// Document represents a document from the Back Office, and follows the PINS Data Model
/// todo: linked to an appeal?
// NOTE: field names match the model rather than the usual camelCase. This avoids extra mapping.
model Document {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // file info
  filename             String
  originalFilename     String
  size                 Int
  mime                 String
  documentURI          String
  publishedDocumentURI String?

  // dates
  dateCreated   DateTime
  dateReceived  DateTime?
  lastModified  DateTime?
  datePublished DateTime?

  // states
  virusCheckStatus String? // nullble?
  published        Boolean  @default(false)
  redacted         Boolean?
  version          Int?
  fileMD5          String?
  owner            String?
  author           String?
  description      String?

  // info
  documentType    String?
  sourceSystem    String?
  origin          String?
  stage           String?
  horizonFolderId String?

  // relations
  caseReference String
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  // indexes
  @@index([caseReference])
  @@index([publishedDocumentURI])
}

// This table stores unedited IP submissions at the point of submission to BO
model InterestedPartySubmission {
  id            String     @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  caseReference String
  firstName     String
  lastName      String
  addressLine1  String?
  addressLine2  String?
  townCity      String?
  county        String?
  postcode      String?
  emailAddress  String?
  comments      String     @db.NVarChar(Max)
  createdAt     DateTime   @default(now())
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  // indexes
  @@index([caseReference])
}

/// ServiceUser represents any user of PINS Services, and follows the PINS Data Model
/// A given person may be represented by multiple ServiceUser entries, for example an agent
/// would have one entry per appeal
///
/// NOTE: ServiceUser should not be used for general queries, use AppealUser and AppealToUser
/// this just exists so we can create the relationships in our model, from Back Office data - which may come out of order
/// we may get an AppealCase before associated ServiceUsers, and visa versa. So we save them to reconcile afterwards.
model ServiceUser {
  /// this ID is for front office only and won't correlate to other systems
  internalId String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  id               String
  salutation       String?
  firstName        String?
  lastName         String?
  emailAddress     String?
  addressLine1     String?
  addressLine2     String?
  addressTown      String?
  addressCounty    String?
  postcode         String?
  addressCountry   String?
  organisation     String?
  organisationType String?
  role             String?
  telephoneNumber  String?
  otherPhoneNumber String?
  faxNumber        String?
  webAddress       String?
  sourceSystem     String?
  sourceSuid       String?

  /// one of "Applicant", "Appellant", "Agent", "RepresentationContact", "Subscriber", "Rule6Party", "InterestedParty"
  serviceUserType String
  /// case reference this user + user-type relates to
  caseReference   String

  // indexes
  @@index([caseReference])
  @@index([emailAddress])
  @@index([caseReference, emailAddress, serviceUserType])
}

/// AppellantSubmission represents an appeal submitted by an appellant
model AppellantSubmission {
  id                        String  @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  LPACode                   String
  appealTypeCode            String // type shortcode such as HAS or S78
  typeOfPlanningApplication String?

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // application
  applicationDecisionDate DateTime?
  applicationDecision     String?

  appealId String @unique @db.UniqueIdentifier
  Appeal   Appeal @relation(fields: [appealId], references: [id])

  // state
  caseTermsAccepted Boolean? /// set when user clicks submit
  submitted         Boolean  @default(false) /// whether the questionnaire has been submitted to BO
  submissionPdfId   String?

  // dates
  onApplicationDate DateTime?

  //appellant / agent details
  isAppellant          Boolean?
  appellantFirstName   String?
  appellantLastName    String?
  appellantCompanyName String?
  contactFirstName     String?
  contactLastName      String?
  contactCompanyName   String?

  // boolean
  ownsAllLand                        Boolean?
  ownsSomeLand                       Boolean?
  knowsAllOwners                     String?
  knowsOtherOwners                   String?
  informedOwners                     Boolean?
  advertisedAppeal                   Boolean?
  appellantGreenBelt                 Boolean?
  updateDevelopmentDescription       Boolean?
  identifiedOwners                   Boolean?
  costApplication                    Boolean?
  appellantProcedurePreference       String?
  agriculturalHolding                Boolean?
  informedTenantsAgriculturalHolding Boolean?
  otherTenantsAgriculturalHolding    Boolean?
  ownershipCertificate               Boolean?
  newPlansDrawings                   Boolean?
  otherNewDocuments                  Boolean?
  designAccessStatement              Boolean?
  planningObligation                 Boolean?
  tenantAgriculturalHolding          Boolean?
  section3aGrant                     Boolean?
  highwayLand                        Boolean?

  // boolean text
  appellantSiteSafety                            String?
  appellantSiteSafety_appellantSiteSafetyDetails String?
  appellantSiteAccess                            String?
  appellantSiteAccess_appellantSiteAccessDetails String?
  statusPlanningObligation                       String?

  // radio
  majorMinorDevelopment String?
  typeDevelopment       String?

  // plain text
  applicationReference           String?
  developmentDescriptionOriginal String?
  appellantLinkedCaseReference   String?
  contactPhoneNumber             String?
  appellantPreferHearingDetails  String?
  appellantPreferInquiryDetails  String?

  // number entries
  siteAreaSquareMetres            Decimal?
  siteAreaUnits                   String?
  appellantPreferInquiryDuration  Int?
  appellantPreferInquiryWitnesses Int?
  siteArea                        Decimal?

  // Linked cases
  appellantLinkedCaseAdd Boolean?
  appellantLinkedCase    Boolean?
  SubmissionLinkedCase   SubmissionLinkedCase[]

  // file uploads
  uploadOriginalApplicationForm     Boolean?
  uploadApplicationDecisionLetter   Boolean?
  uploadAppellantStatement          Boolean?
  uploadCostApplication             Boolean?
  uploadChangeOfDescriptionEvidence Boolean?
  uploadOwnershipCertificate        Boolean?
  uploadStatementCommonGround       Boolean?
  uploadDesignAccessStatement       Boolean?
  uploadPlansDrawings               Boolean?
  uploadNewPlansDrawings            Boolean?
  uploadOtherNewDocuments           Boolean?
  uploadPlanningObligation          Boolean?
  SubmissionDocumentUpload          SubmissionDocumentUpload[]

  // addresses
  siteAddress              Boolean?
  SubmissionAddress        SubmissionAddress[]
  SubmissionListedBuilding SubmissionListedBuilding[]
}

/// LPAQuestionnaireSubmission represents the questionnaire responses from an LPAUser
model LPAQuestionnaireSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  appealCaseReference String     @unique
  AppealCase          AppealCase @relation(fields: [appealCaseReference], references: [caseReference])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the appeal has been submitted to BO

  submissionPdfId                                 String?
  correctAppealType                               Boolean?
  affectsListedBuilding                           Boolean?
  affectedListedBuildingNumber                    String?
  addAffectedListedBuilding                       Boolean?
  changesListedBuilding                           Boolean?
  changedListedBuildingNumber                     String?
  addChangedListedBuilding                        Boolean?
  conservationArea                                Boolean?
  uploadConservation                              Boolean?
  greenBelt                                       Boolean?
  uploadWhoNotified                               Boolean?
  uploadLettersEmails                             Boolean?
  uploadPressAdvert                               Boolean?
  consultationResponses                           Boolean?
  uploadConsultationResponses                     Boolean?
  notificationMethod                              String?
  uploadSiteNotice                                Boolean?
  otherPartyRepresentations                       Boolean?
  uploadRepresentations                           Boolean?
  uploadPlanningOfficerReport                     Boolean?
  uploadPlansDrawings                             Boolean?
  lpaSiteAccess                                   String?
  lpaSiteAccess_lpaSiteAccessDetails              String?
  neighbourSiteAccess                             String?
  neighbourSiteAccess_neighbourSiteAccessDetails  String?
  addNeighbourSiteAccess                          Boolean?
  neighbourSiteAddress                            Boolean?
  lpaSiteSafetyRisks                              String?
  lpaSiteSafetyRisks_lpaSiteSafetyRiskDetails     String?
  lpaProcedurePreference                          String?
  lpaPreferHearingDetails                         String?
  lpaProcedurePreference_lpaPreferInquiryDuration String?
  lpaPreferInquiryDetails                         String?
  nearbyAppeals                                   Boolean?
  addNearbyAppeal                                 Boolean?
  newConditions                                   String?
  newConditions_newConditionDetails               String?   @db.NVarChar(Max)
  emergingPlan                                    Boolean?
  uploadEmergingPlan                              Boolean?
  developmentPlanPolicies                         Boolean?
  uploadDevelopmentPlanPolicies                   Boolean?
  otherRelevantPolicies                           Boolean?
  uploadOtherPolicies                             Boolean?
  infrastructureLevy                              Boolean?
  uploadInfrastructureLevy                        Boolean?
  infrastructureLevyAdopted                       Boolean?
  infrastructureLevyAdoptedDate                   DateTime?
  infrastructureLevyExpectedDate                  DateTime?
  uploadLettersInterestedParties                  Boolean?
  treePreservationOrder                           Boolean?
  uploadTreePreservationOrder                     Boolean?
  uploadDefinitiveMapStatement                    Boolean?
  supplementaryPlanningDocs                       Boolean?
  uploadSupplementaryPlanningDocs                 Boolean?
  affectsScheduledMonument                        Boolean?
  gypsyTraveller                                  Boolean?
  statutoryConsultees                             String?
  statutoryConsultees_consultedBodiesDetails      String?
  protectedSpecies                                Boolean?
  publicRightOfWay                                Boolean?
  areaOutstandingBeauty                           Boolean?
  designatedSites                                 String?
  designatedSites_otherDesignations               String?
  screeningOpinion                                Boolean?
  scopingOpinion                                  Boolean?
  uploadScopingOpinion                            Boolean?
  environmentalStatement                          Boolean?
  environmentalImpactSchedule                     String?
  uploadEnvironmentalStatement                    Boolean?
  columnTwoThreshold                              Boolean?
  sensitiveArea                                   String?
  sensitiveArea_sensitiveAreaDetails              String?
  uploadScreeningOpinion                          Boolean?
  uploadScreeningDirection                        Boolean?
  developmentDescription                          String?
  applicantSubmittedEnvironmentalStatement        String?
  appealNotification                              Boolean?
  demolishAlterExtend                             Boolean?
  consultHistoricEngland                          Boolean?
  listedBuildingGrade                             String?
  uploadHistoricEnglandConsultation               Boolean?
  section3aGrant                                  Boolean?

  // Uploaded documents and details linked to this appeal
  SubmissionDocumentUpload SubmissionDocumentUpload[]
  SubmissionAddress        SubmissionAddress[]
  SubmissionLinkedCase     SubmissionLinkedCase[]
  SubmissionListedBuilding SubmissionListedBuilding[]

  // indexes
  @@index([appealCaseReference])
}

model LPAStatementSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  appealCaseReference String     @unique
  AppealCase          AppealCase @relation(fields: [appealCaseReference], references: [caseReference])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the lpa statement has been submitted to BO

  lpaStatement        String?  @db.NVarChar(Max)
  additionalDocuments Boolean?

  // Uploaded documents and details linked to this statement
  uploadLpaStatementDocuments Boolean?
  SubmissionDocumentUpload    SubmissionDocumentUpload[]

  // indexes
  @@index([appealCaseReference])
}

model Rule6StatementSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  caseReference String     @unique
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  /// relation to a User - required as can have more than one rule6 party per apeal
  userId     String     @db.UniqueIdentifier
  AppealUser AppealUser @relation(fields: [userId], references: [id])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the lpa statement has been submitted to BO

  rule6Statement                String?  @db.NVarChar(Max)
  rule6AdditionalDocuments      Boolean?
  uploadRule6StatementDocuments Boolean?

  // Uploaded documents and details linked to this statement
  SubmissionDocumentUpload SubmissionDocumentUpload[]

  // indexes
  @@index([caseReference])
}

model AppellantProofOfEvidenceSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  caseReference String     @unique
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the proof of evidence has been submitted to BO

  uploadAppellantProofOfEvidenceDocuments Boolean?
  appellantWitnesses                      Boolean?
  uploadAppellantWitnessesEvidence        Boolean?

  // Uploaded documents and details linked to this proof of evidence
  SubmissionDocumentUpload SubmissionDocumentUpload[]

  // indexes
  @@index([caseReference])
}

model Rule6ProofOfEvidenceSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  caseReference String     @unique
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  /// relation to a User
  userId     String     @db.UniqueIdentifier
  AppealUser AppealUser @relation(fields: [userId], references: [id])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the proof of evidence has been submitted to BO

  uploadRule6ProofOfEvidenceDocuments Boolean?
  rule6Witnesses                      Boolean?
  uploadRule6WitnessesEvidence        Boolean?

  // Uploaded documents and details linked to this proof of evidence
  SubmissionDocumentUpload SubmissionDocumentUpload[]

  // indexes
  @@index([caseReference])
}

model LPAProofOfEvidenceSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  caseReference String     @unique
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the appeal has been submitted to BO

  uploadLpaProofOfEvidenceDocuments Boolean?
  lpaWitnesses                      Boolean?
  uploadLpaWitnessesEvidence        Boolean?

  // Uploaded documents and details linked to this appeal
  SubmissionDocumentUpload SubmissionDocumentUpload[]

  // indexes
  @@index([caseReference])
}

model LPAFinalCommentSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  caseReference String     @unique
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the final comment has been submitted to BO

  lpaFinalComment                Boolean?
  lpaFinalCommentDetails         String?  @db.NVarChar(MAX)
  lpaFinalCommentDocuments       Boolean?
  uploadLPAFinalCommentDocuments Boolean?

  // Uploaded documents and details linked to this final comment
  SubmissionDocumentUpload SubmissionDocumentUpload[]

  // indexes
  @@index([caseReference])
}

model AppellantFinalCommentSubmission {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  // link the submission to the appeal
  caseReference String     @unique
  AppealCase    AppealCase @relation(fields: [caseReference], references: [caseReference])

  // dates
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  // state
  submitted Boolean @default(false) /// whether the final comment has been submitted to BO

  appellantFinalComment                Boolean?
  appellantFinalCommentDetails         String?  @db.NVarChar(MAX)
  appellantFinalCommentDocuments       Boolean?
  uploadAppellantFinalCommentDocuments Boolean?

  // Uploaded documents and details linked to this final comment
  SubmissionDocumentUpload SubmissionDocumentUpload[]

  // indexes
  @@index([caseReference])
}

model SubmissionDocumentUpload {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  questionnaireId            String?                     @db.UniqueIdentifier
  LPAQuestionnaireSubmission LPAQuestionnaireSubmission? @relation(fields: [questionnaireId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  appellantSubmissionId String?              @db.UniqueIdentifier
  AppellantSubmission   AppellantSubmission? @relation(fields: [appellantSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  lpaStatementId         String?                 @db.UniqueIdentifier
  LPAStatementSubmission LPAStatementSubmission? @relation(fields: [lpaStatementId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  appellantFinalCommentId         String?                          @db.UniqueIdentifier
  AppellantFinalCommentSubmission AppellantFinalCommentSubmission? @relation(fields: [appellantFinalCommentId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  lpaFinalCommentId         String?                    @db.UniqueIdentifier
  LPAFinalCommentSubmission LPAFinalCommentSubmission? @relation(fields: [lpaFinalCommentId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  appellantProofOfEvidenceId         String?                             @db.UniqueIdentifier
  AppellantProofOfEvidenceSubmission AppellantProofOfEvidenceSubmission? @relation(fields: [appellantProofOfEvidenceId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  lpaProofOfEvidenceId         String?                       @db.UniqueIdentifier
  LPAProofOfEvidenceSubmission LPAProofOfEvidenceSubmission? @relation(fields: [lpaProofOfEvidenceId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  Rule6ProofOfEvidenceSubmission   Rule6ProofOfEvidenceSubmission? @relation(fields: [rule6ProofOfEvidenceSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  rule6ProofOfEvidenceSubmissionId String?                         @db.UniqueIdentifier

  Rule6StatementSubmission   Rule6StatementSubmission? @relation(fields: [rule6StatementSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  rule6StatementSubmissionId String?                   @db.UniqueIdentifier

  name             String
  fileName         String
  originalFileName String
  location         String
  type             String
  storageId        String @default("")

  // indexes
  @@index([questionnaireId])
  @@index([appellantSubmissionId])
  @@index([lpaStatementId])
  @@index([appellantFinalCommentId])
  @@index([lpaFinalCommentId])
  @@index([appellantProofOfEvidenceId])
  @@index([lpaProofOfEvidenceId])
  @@index([rule6ProofOfEvidenceSubmissionId])
  @@index([rule6StatementSubmissionId])
}

model SubmissionAddress {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  questionnaireId            String?                     @db.UniqueIdentifier
  LPAQuestionnaireSubmission LPAQuestionnaireSubmission? @relation(fields: [questionnaireId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  appellantSubmissionId String?              @db.UniqueIdentifier
  AppellantSubmission   AppellantSubmission? @relation(fields: [appellantSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  addressLine1 String
  addressLine2 String?
  townCity     String
  county       String?
  postcode     String

  // the fieldName of the questionnaire question / subquestion - required for display filtering
  fieldName String

  // indexes
  @@index([questionnaireId])
  @@index([appellantSubmissionId])
}

model SubmissionLinkedCase {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  lPAQuestionnaireSubmissionId String?                     @db.UniqueIdentifier
  LPAQuestionnaireSubmission   LPAQuestionnaireSubmission? @relation(fields: [lPAQuestionnaireSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  appellantSubmissionId String?              @db.UniqueIdentifier
  AppellantSubmission   AppellantSubmission? @relation(fields: [appellantSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  caseReference String

  // the fieldName of the questionnaire question / subquestion - required for display filtering
  fieldName String

  // indexes
  @@index([lPAQuestionnaireSubmissionId])
  @@index([appellantSubmissionId])
}

model SubmissionListedBuilding {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  lPAQuestionnaireSubmissionId String?                     @db.UniqueIdentifier
  LPAQuestionnaireSubmission   LPAQuestionnaireSubmission? @relation(fields: [lPAQuestionnaireSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  appellantSubmissionId String?              @db.UniqueIdentifier
  AppellantSubmission   AppellantSubmission? @relation(fields: [appellantSubmissionId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  reference           String
  name                String
  listedBuildingGrade String

  // the fieldName of the questionnaire question / subquestion - required for display filtering
  fieldName String

  // indexes
  @@index([lPAQuestionnaireSubmissionId])
  @@index([appellantSubmissionId])
}

/// Proofs of Evidence, Final Comments, Statements, Planning Obligations and Interested Party Comments
/// Received from BO will share this model and table
model Representation {
  /// this ID is for front office only
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  representationId                String                   @unique /// The unique identifier for the representation
  caseId                          Int? /// Internal case identifier
  caseReference                   String /// External case identifier
  AppealCase                      AppealCase               @relation(fields: [caseReference], references: [caseReference])
  representationStatus            String? /// Status of the representation, [ "awaiting_review", "referred", "valid", "invalid", "published", "archived", "draft", "withdrawn", null ]
  originalRepresentation          String?                  @db.NVarChar(Max) /// The original representation
  redacted                        Boolean? /// Indicates if the representation is redacted
  redactedRepresentation          String?                  @db.NVarChar(Max) /// The redacted version of the representation
  redactedBy                      String? /// Unique identifier for the case team member that performed the redaction
  invalidOrIncompleteDetails      String? /// A json array of reasons why the representation has been marked as invalid
  otherInvalidOrIncompleteDetails String? /// A json array of free text other reasons why the representation has been marked as invalid
  source                          String? /// Source of the representation (citizen or LPA), ["lpa", "citizen"]
  serviceUserId                   String? /// Service User Id of the person or organisation making the representation
  representationType              String? /// The type of representation, ["statement", "comment", "final_comment", "proofs_evidence", null]
  dateReceived                    DateTime?
  RepresentationDocuments         RepresentationDocument[]

  // indexes
  @@index([caseReference])
}

/// Join table to link document to representation
model RepresentationDocument {
  id               String         @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  representationId String         @db.UniqueIdentifier
  documentId       String         @db.UniqueIdentifier
  Representation   Representation @relation(fields: [representationId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  // indexes
  @@index([representationId])
  @@index([documentId])
}

/// Proofs of Evidence, Final Comments, Statements, Planning Obligations and Interested Party Comments
/// Received from BO will share this model and table
model LPA {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  objectId String?
  lpa19CD  String?
  lpaCode  String?
  name     String?
  email    String?
  domain   String?
  inTrial  Boolean

  // indexes
  @@index([lpaCode])
  @@index([lpa19CD])
}
