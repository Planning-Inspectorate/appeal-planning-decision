generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "darwin"]
}

datasource db {
  provider = "sqlserver"
  url      = env("SQL_CONNECTION_STRING_ADMIN")
}

// NOTES
//
// use '//' comments for notes relevant to the schema
// use '///' comments for notes that should be included in the types definition
// see https://www.prisma.io/docs/concepts/components/prisma-schema#comments
//
// we use GUIDs for IDs (see https://learn.microsoft.com/en-us/sql/t-sql/data-types/uniqueidentifier-transact-sql?view=sql-server-ver16)
// this is because these IDs may be used in URLs and it makes them harder to guess
// while we don't rely on that for security, it adds an extra layer
// not everything needs this, but easier to make them all consistent and the increase in size (vs int) is negligible

/// AppealUser represents a user of our service(s)
/// this may be an appellant, agent, or LPA employee
model AppealUser {
  id         String  @id @default(dbgenerated("newid()")) @db.UniqueIdentifier
  email      String  @unique
  /// has this user been enrolled?
  /// in practice this means have they been sent a registration confirmation email
  /// this is sent to all users when they first use the system
  ///
  /// this flag is here for users created as part of migration, or from a back office ServiceUser message
  /// they need an email sent when they first login
  isEnrolled Boolean @default(false)

  /// a service user entity will be broadcast by the back office. We match them to AppealUser by email
  /// appeals will be matched to users by serviceUserId.
  serviceUserId Int? // unique, with nulls allowed, is enforced in SQL, see first migration script & https://stackoverflow.com/a/767702
  // -- unique AppealUser.serviceUserId
  // CREATE UNIQUE NONCLUSTERED INDEX idx_AppealUser_serviceUserId_unique_notnull
  // ON [dbo].[AppealUser](serviceUserId)
  // WHERE serviceUserId IS NOT NULL;

  // LPA user fields
  /// is this an LPA user?
  isLpaUser  Boolean  @default(false)
  /// if an LPA user, the LPA this user belongs to
  lpaCode    String?
  /// if an LPA user, whether this user is an admin for that LPA
  isLpaAdmin Boolean?
  /// if an LPA user, the status of this user, e.g. have they logged in and confirmed their email?
  lpaStatus  String? /// added | confirmed | removed

  /// appeals this user is linked to, by being the appellant or agent, for example
  Appeals AppealToUser[]

  /// a security token this user can use to access our service(s)
  SecurityToken SecurityToken?
}

/// SecurityToken is used as a mechanism for users to login
/// They enter their email, a token is generated, emailed to the user, and they enter it to login
/// A user only ever has one token, which gets updated when a new token is required
model SecurityToken {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  /// link to a user
  appealUserId String     @unique @db.UniqueIdentifier
  AppealUser   AppealUser @relation(fields: [appealUserId], references: [id])

  /// the generated token the user can login with
  token            String
  /// the time the token was generated, used for checking token expiry
  tokenGeneratedAt DateTime
  /// the number of attempts at entering the code since this token was last generated
  /// this MUST be updated in a transaction to ensure atomic operation
  /// see https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#atomic-number-operations
  attempts         Int      @default(0)
  /// the action the code was generated for, e.g. confirmEmail
  action           String?
}

/// Appeal is the base appeal model, used to link references to other entities, which includes, for example:
/// - an appeal submission authored in the front office
/// - a case published by the back office
/// - an LPA questionnaire submission
model Appeal {
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  /// users linked to this appeal, such as the appellant or agent
  Users AppealToUser[]

  /// reference to an appeal submission in the Cosmos DB `appeals` collection
  /// we sync across two properties, as below
  /// this is so we can query for draft submissions where the deadline date has passed (to delete them)
  legacyAppealSubmissionId           String?
  /// the deadline date of the appeal submission in the Cosmos DB `appeals` collection
  legacyAppealSubmissionDecisionDate DateTime?
  /// the state of the appeal submission in the Cosmos DB `appeals` collection
  legacyAppealSubmissionState        String? /// DRAFT || SUBMITTED

  /// link to case (from Back Office)
  AppealCase AppealCase?

  // todo: in the future link to appeal submission and other data
}

/// AppealToUser represents the relationships between AppealUser and Appeal
/// This is a many-to-many relationship.
model AppealToUser {
  /// relation to an Appeal
  appealId   String     @db.UniqueIdentifier
  Appeal     Appeal     @relation(fields: [appealId], references: [id])
  /// relation to a User
  userId     String     @db.UniqueIdentifier
  AppealUser AppealUser @relation(fields: [userId], references: [id])

  /// the role the user has in relation to the appeal
  /// must be an AppealToUserRole name value
  role String
  Role AppealToUserRole @relation(fields: [role], references: [name])

  @@id([appealId, userId])
}

/// AppealToUserRole represents the role a user has in relation to an Appeal
/// This reference table acts as an enum of allowed values
model AppealToUserRole {
  /// the unique name of this role such as appellant, agent, interestedParty
  /// this is a machine-readable name not a user-friendly name; i.e. lowerCamelCase
  name        String  @id
  /// the description for this role, such as
  /// "an agent is a user who submits an appeal on behalf of an appellant"
  description String?

  AppealToUser AppealToUser[]
}

/// AppealCase represents an Appeal from the Back Office, and follows the PINS Data Model
/// Cases aren't linked to users directly, but there's a 1:1 mapping to Appeal, which has a link to user
// NOTE: field names match the model rather than the usual camelCase. This avoids extra mapping.
model AppealCase {
  /// this ID is for front office only and won't correlate to other systems
  id String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  //***************************************************************************
  // general fields
  //***************************************************************************

  /// unique case reference
  caseReference String @unique
  LPACode       String

  //***************************************************************************
  // appellant case fields
  //***************************************************************************

  LPAName                         String
  appealTypeCode                  String // type shortcode such as HAS or S78
  appealTypeName                  String // type name such as Householder or Full Planning
  decision                        String
  originalCaseDecisionDate        DateTime
  costsAppliedForIndicator        Boolean
  LPAApplicationReference         String
  appellantCasePublished          Boolean  @default(false)
  appellantProofEvidenceSubmitted Boolean  @default(false)
  appellantProofEvidencePublished Boolean  @default(false)
  appellantFinalCommentsSubmitted Boolean  @default(false)

  appellantFirstName String @default("")
  appellantLastName  String @default("")

  siteAddressLine1    String
  siteAddressLine2    String?
  siteAddressTown     String?
  siteAddressCounty   String?
  siteAddressPostcode String

  //***************************************************************************
  // LPA questionnaire fields
  //***************************************************************************

  questionnaireDueDate  DateTime?
  questionnaireReceived DateTime?

  lpaQuestionnairePublished    Boolean  @default(false)
  lpaQuestionnaireSubmitted    Boolean  @default(false)
  doesAffectAScheduledMonument Boolean?
  lpaStatementPublished        Boolean  @default(false)
  lpaProofEvidenceSubmitted    Boolean  @default(false)
  lpaProofEvidencePublished    Boolean  @default(false)
  lpaFinalCommentsPublished    Boolean  @default(false)

  //***************************************************************************
  // rule 6 fields
  //***************************************************************************

  rule6StatementPublished      Boolean @default(false)
  rule6ProofsEvidencePublished Boolean @default(false)

  //***************************************************************************
  // interested party fields
  //***************************************************************************

  interestedPartyCommentsPublished Boolean @default(false)

  //***************************************************************************
  // case dates
  //***************************************************************************

  casePublished     Boolean   @default(false)
  casePublishedDate DateTime?

  receiptDate                DateTime?
  startDate                  DateTime?
  appealValidDate            DateTime?
  caseDecisionDate           DateTime?
  interestedPartyRepsDueDate DateTime?

  // statement
  statementDueDate            DateTime?
  appellantStatementForwarded DateTime?
  appellantStatementSubmitted DateTime?
  LPAStatementForwarded       DateTime?
  LPAStatementSubmitted       DateTime?

  // comments
  finalCommentsDueDate       DateTime?
  appellantCommentsForwarded DateTime?
  appellantCommentsSubmitted DateTime?
  LPACommentsForwarded       DateTime?
  LPACommentsSubmitted       DateTime?

  // proofs of evidence
  proofsOfEvidenceDueDate   DateTime?
  appellantsProofsForwarded DateTime?
  appellantsProofsSubmitted DateTime?
  LPAProofsForwarded        DateTime?
  LPAProofsSubmitted        DateTime?

  // viewAppeal epic aapd-1187
  procedure             String?
  outcome               String?
  caseDecisionOutcome   String?
  caseDecisionPublished Boolean? @default(false)

  // todo: there are many more fields! waiting on the model definition

  /// link to root Appeal
  appealId String @unique @db.UniqueIdentifier
  Appeal   Appeal @relation(fields: [appealId], references: [id])

  // todo: indexes
}

/// ServiceUser represents any user of PINS Services, and follows the PINS Data Model
/// A given person may be represented by multiple ServiceUser entries, for example an agent
/// would have one entry per appeal
///
/// NOTE: ServiceUser should not be used for general queries, use AppealUser and AppealToUser
/// this just exists so we can create the relationships in our model, from Back Office data - which may come out of order
/// we may get an AppealCase before associated ServiceUsers, and visa versa. So we save them to reconcile afterwards.
model ServiceUser {
  /// this ID is for front office only and won't correlate to other systems
  internalId String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  id              String
  salutation      String?
  firstName       String?
  lastName        String?
  emailAddress    String?
  /// one of "Applicant", "Appellant", "Agent", "RepresentationContact", "Subscriber"
  serviceUserType String
  /// case reference this user + user-type relates to
  caseReference   String
}

/// LPAQuestionnaireSubmission represents the questionnaire responses from an LPAUser
model LPAQuestionnaireSubmission {
  /// this ID is for front office only and won't correlate to other systems
  internalId String @id @default(dbgenerated("newid()")) @db.UniqueIdentifier

  id String

  caseReference String

  // s78 questionnaire

  changesListedBuilding           Boolean?
  changedListedBuildingNumber     Int?
  addChangedListedBuilding        Boolean?
  affectsScheduledMonument        Boolean?
  conservationArea                Boolean?
  //upload conservation map?
  protectedSpecies                Boolean?
  greenBelt                       Boolean?
  areaOutstandingBeauty           Boolean?
  // designatedSites
  otherDesignationDetails         String?
  treePreservationOrder           Boolean?
  //upload tree preservation order?
  gypsyTraveller                  Boolean?
  publicRightOfWay                Boolean?
  //upload definitive map?
  // environmentalImpactSchedule
  // developmentDescription
  sensitiveArea                   Boolean?
  sensitiveAreaDetails            String?
  columnTwoThreshold              Boolean?
  screeningOpinion                Boolean?
  requiresEnvironmentalStatement  Boolean?
  completedEnvironmentalStatement Boolean?
  statutoryConsultees             Boolean?
  consultedBodiesDetails          String?
  consultationResponses           Boolean?
  otherPartyRepresentations       Boolean?
  emergingPlan                    Boolean?
  supplementaryPlanningDocs       Boolean?
  infrastructureLevy              Boolean?
  infrastructureLevyAdopted       Boolean?
  infrastructureLevyAdoptedDate   DateTime?
  infrastructureLevyExpectedDate  DateTime?
  appealSiteAccess                Boolean?
  // appealSiteAccessDetails							String?
  neighbourSiteAccess             Boolean?
  // neighbourSiteAccessDetails				String?
  // neighbourSiteAddress
  // lpaProcedurePreference							String?
  lpaPreferHearingDetails         String?
  // lpaPreferInquiryDuration						String?
  lpaPreferInquiryDetails         String?
  nearbyAppeals                   Boolean?
  nearbyAppealReference           String?
  addNearbyAppeal                 Boolean?
  newConditions                   Boolean?
  newConditionDetails             String?
  lpaStatement                    String?
  lpaStatementDocuments           Boolean?
  lpaFinalComment                 Boolean?
  lpaFinalCommentDetails          String?
  lpaWitnesses                    Boolean?

  // HAS questionnaire
  correctAppealType            Boolean?
  affectsListedBuilding        Boolean?
  affectedListedBuildingNumber Int?
  addAffectedListedBuilding    Boolean?
  addNeighbourSiteAccess       Boolean?
  lpaSiteSafetyRisks           Boolean?
  lpaSiteSafetyRiskDetails     String?
}
